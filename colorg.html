<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Color Spaces — Unique & Larger Visualizations</title>
    <style>
      :root {
        --bg: #0e0e10;
        --panel: #111218;
        --ring: #2a2e39;
        --text: #e5e7eb;
        --muted: #9aa1ad;
      }
      body {
        margin: 0;
        background: var(--bg);
        color: var(--text);
        font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      }
      header {
        padding: 16px 20px;
      }
      header h1 {
        margin: 0 0 4px;
        font-size: 18px;
      }
      header p {
        margin: 0;
        color: var(--muted);
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 16px;
        padding: 16px;
        box-sizing: border-box;
      }
      @media (max-width: 1200px) {
        .grid {
          grid-template-columns: 1fr;
        }
      }
      .panel {
        position: relative;
        background: var(--panel);
        border: 1px solid var(--ring);
        border-radius: 14px;
        overflow: hidden;
        height: 520px;
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.35), inset 0 1px 0 rgba(255, 255, 255, 0.02);
      }
      .panel .title {
        position: absolute;
        left: 12px;
        top: 10px;
        z-index: 5;
        padding: 6px 10px;
        border-radius: 8px;
        font-weight: 600;
        background: rgba(0, 0, 0, 0.35);
        backdrop-filter: blur(6px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
      }
      .panel .controls {
        position: absolute;
        right: 10px;
        top: 8px;
        z-index: 5;
        display: flex;
        gap: 8px;
      }
      .panel button {
        appearance: none;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: rgba(20, 20, 24, 0.6);
        color: #fff;
        border-radius: 8px;
        padding: 6px 10px;
        cursor: pointer;
        font-weight: 600;
        backdrop-filter: blur(6px);
      }
      .panel button:hover {
        background: rgba(30, 30, 40, 0.7);
      }
      .panel button.close {
        padding: 6px 9px;
        border-radius: 50%;
        width: 32px;
        height: 32px;
        line-height: 18px;
      }
      .view {
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        height: 64%;
        border-bottom: 1px solid var(--ring);
      }
      canvas.webgl {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
      }
      .sliders {
        position: absolute;
        left: 0;
        right: 0;
        top: 64%;
        height: 20%;
        padding: 10px 12px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
        background: rgba(0, 0, 0, 0.25);
      }
      .row {
        display: grid;
        grid-template-columns: 54px 1fr 60px;
        align-items: center;
        gap: 10px;
      }
      .row label {
        color: #cbd1db;
        font-weight: 600;
      }
      .row output {
        text-align: right;
        font-variant-numeric: tabular-nums;
        color: #e8eaef;
      }
      input[type="range"] {
        width: 100%;
        accent-color: #7aa0ff;
      }
      .status {
        position: absolute;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 4;
        margin: 0 auto;
        padding: 10px 14px;
        text-align: center;
        border-radius: 10px 10px 0 0;
        max-width: min(92vw, 1200px);
        box-shadow: 0 -8px 24px rgba(0, 0, 0, 0.25);
        background: rgba(255, 255, 255, 0.75);
        color: #000;
      }
      .dock {
        position: fixed;
        left: 16px;
        bottom: 16px;
        z-index: 2147483647;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        max-width: 80vw;
      }
      .dock button {
        appearance: none;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(30, 32, 42, 0.8);
        color: #fff;
        border-radius: 10px;
        padding: 8px 10px;
        cursor: pointer;
        font-weight: 700;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.35);
        backdrop-filter: blur(6px);
      }
      .dock button:hover {
        background: rgba(40, 42, 56, 0.85);
      }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three/build/three.module.js",
          "three/addons/": "https://unpkg.com/three/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <header>
      <h1>Color Spaces — Multi-Panel Visualizer</h1>
      <p>
        Panels start at random indexes and update once per second. Drag to orbit. Close with “×”; restore from the dock.
      </p>
    </header>

    <section class="grid">
      <div class="panel" id="rgbPanel"><div class="title">RGB (24-bit)</div></div>
      <div class="panel" id="hsvPanel"><div class="title">HSV (discrete grid)</div></div>
      <div class="panel" id="hslPanel"><div class="title">HSL (discrete grid)</div></div>
      <div class="panel" id="cmykPanel"><div class="title">CMYK → sRGB</div></div>
      <div class="panel" id="yuvPanel"><div class="title">YUV (BT.601-style)</div></div>
    </section>

    <div class="dock" id="dock"></div>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
      import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

      // ---- shared utils ----
      const nf = new Intl.NumberFormat();
      const fmt = (n) => nf.format(n);
      const SECOND = 1000;
      const dock = document.getElementById("dock");
      const restoreButtons = {};
      const clamp01 = (x) => Math.min(1, Math.max(0, x));

      function addRestoreButton(panelId, label, onClick) {
        if (restoreButtons[panelId]) return;
        const btn = document.createElement("button");
        btn.textContent = `Show ${label}`;
        btn.onclick = () => {
          onClick();
          removeRestoreButton(panelId);
        };
        dock.appendChild(btn);
        restoreButtons[panelId] = btn;
      }

      function removeRestoreButton(panelId) {
        const btn = restoreButtons[panelId];
        if (btn) {
          btn.remove();
          delete restoreButtons[panelId];
        }
      }

      function fmtDurationSeconds(sec) {
        sec = Math.max(0, Math.floor(sec));
        const y = Math.floor(sec / 31536000);
        sec %= 31536000;
        const d = Math.floor(sec / 86400);
        sec %= 86400;
        const h = Math.floor(sec / 3600);
        sec %= 3600;
        const m = Math.floor(sec / 60);
        const s = sec % 60;
        return (
          (y ? `${y}y ` : "") +
          (y || d ? `${d}d ` : "") +
          `${String(h).padStart(2, "0")}:${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`
        );
      }

      function setBarContrast(r, g, b, bar) {
        const luma = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        bar.style.color = luma < 120 ? "#fff" : "#000";
        bar.style.background = luma < 120 ? "rgba(0,0,0,.45)" : "rgba(255,255,255,.75)";
      }
      const setSliderAccent = (el, cssColor) => {
        el.style.accentColor = cssColor;
      };

      function makePanelScaffold(container) {
        const view = document.createElement("div");
        view.className = "view";
        const canvas = document.createElement("canvas");
        canvas.className = "webgl";
        const sliders = document.createElement("div");
        sliders.className = "sliders";
        const status = document.createElement("div");
        status.className = "status";
        const controls = document.createElement("div");
        controls.className = "controls";
        const btnPause = document.createElement("button");
        btnPause.textContent = "Pause";
        const btnClose = document.createElement("button");
        btnClose.textContent = "×";
        btnClose.className = "close";

        view.appendChild(canvas);
        controls.appendChild(btnPause);
        controls.appendChild(btnClose);
        container.append(view, sliders, status, controls);

        return { view, canvas, sliders, status, btnPause, btnClose };
      }

      function makeRendererAndScene(canvas, container, { fov = 45, near = 0.1, far = 100 } = {}) {
        const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.outputColorSpace = THREE.SRGBColorSpace;

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(fov, 16 / 9, near, far);
        camera.position.set(2.2, 2.0, 2.2);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        const dir = new THREE.DirectionalLight(0xffffff, 0.9);
        dir.position.set(3, 4, 5);
        const amb = new THREE.AmbientLight(0xffffff, 0.25);
        scene.add(dir, amb);

        const onResize = () => {
          const r = container.getBoundingClientRect();
          const w = Math.max(1, Math.floor(r.width));
          const h = Math.max(1, Math.floor(r.height * 0.64));
          renderer.setSize(w, h, false);
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
        };

        const ro = new ResizeObserver(onResize);
        ro.observe(container);
        requestAnimationFrame(onResize);

        return { renderer, scene, camera, controls, stopResize: () => ro.disconnect() };
      }

      function makeSliderRow(
        parent,
        labelText,
        { min = 0, max = 255, step = 1, value = 0, color = "#7aa0ff" } = {},
        onInput
      ) {
        const row = document.createElement("div");
        row.className = "row";
        const label = document.createElement("label");
        label.textContent = labelText;
        const input = document.createElement("input");
        Object.assign(input, { type: "range", min, max, step, value });
        setSliderAccent(input, color);
        const out = document.createElement("output");
        out.textContent = value;
        input.addEventListener("input", () => {
          out.textContent = input.value;
          onInput?.(Number(input.value));
        });
        row.append(label, input, out);
        parent.appendChild(row);
        return { input, out, setAccent: (c) => setSliderAccent(input, c) };
      }

      // ---------- RGB ----------
      function createRGBWidget(container, { startIndex, intervalMs = SECOND, gridSteps = 12 } = {}) {
        const TOTAL = 256 * 256 * 256;
        if (startIndex == null) startIndex = Math.floor(Math.random() * TOTAL);

        const { view, canvas, sliders, status, btnPause, btnClose } = makePanelScaffold(container);
        const { renderer, scene, camera, controls } = makeRendererAndScene(canvas, container);

        const box = new THREE.LineSegments(
          new THREE.EdgesGeometry(new THREE.BoxGeometry(1, 1, 1)),
          new THREE.LineBasicMaterial({ color: 0x888888 })
        );
        box.position.set(0.5, 0.5, 0.5);
        scene.add(box);

        const count = gridSteps ** 3;
        const pos = new Float32Array(count * 3),
          col = new Float32Array(count * 3);
        for (let i = 0, k = 0; i < gridSteps; i++) {
          for (let j = 0; j < gridSteps; j++) {
            for (let l = 0; l < gridSteps; l++) {
              const x = i / (gridSteps - 1),
                y = j / (gridSteps - 1),
                z = l / (gridSteps - 1);
              pos.set([x, y, z], k);
              col.set([x, y, z], k);
              k += 3;
            }
          }
        }
        const geo = new THREE.BufferGeometry();
        geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
        geo.setAttribute("color", new THREE.BufferAttribute(col, 3));
        scene.add(
          new THREE.Points(
            geo,
            new THREE.PointsMaterial({ size: 0.075, vertexColors: true, transparent: true, opacity: 0.9 })
          )
        );

        const marker = new THREE.Mesh(
          new THREE.SphereGeometry(0.04, 32, 32),
          new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x222222, metalness: 0.2, roughness: 0.4 })
        );
        scene.add(marker);

        const sR = makeSliderRow(sliders, "R", { color: "#ff3a3a" }, onR);
        const sG = makeSliderRow(sliders, "G", { color: "#27c34a" }, onG);
        const sB = makeSliderRow(sliders, "B", { color: "#2d7dff" }, onB);

        let idx = startIndex % TOTAL,
          paused = false,
          hidden = false;
        const idxToRGB = (i) => [(i >>> 16) & 255, (i >>> 8) & 255, i & 255];
        const rgbToIdx = (r, g, b) => (r << 16) | (g << 8) | b;

        function paintByIndex(i) {
          const [r, g, b] = idxToRGB(i);
          sR.input.value = sR.out.textContent = r;
          sG.input.value = sG.out.textContent = g;
          sB.input.value = sB.out.textContent = b;
          view.style.background = `rgb(${r}, ${g}, ${b})`;
          setBarContrast(r, g, b, status);
          marker.position.set(r / 255, g / 255, b / 255);
          const remaining = TOTAL - (i + 1);
          status.textContent = `RGB ${r},${g},${b} • ${fmt(i + 1)} of ${fmt(TOTAL)} • remaining: ${fmtDurationSeconds(
            remaining
          )}`;
        }
        function onR(v) {
          paused = true;
          btnPause.textContent = "Resume";
          idx = rgbToIdx(v, +sG.input.value, +sB.input.value);
          paintByIndex(idx);
        }
        function onG(v) {
          paused = true;
          btnPause.textContent = "Resume";
          idx = rgbToIdx(+sR.input.value, v, +sB.input.value);
          paintByIndex(idx);
        }
        function onB(v) {
          paused = true;
          btnPause.textContent = "Resume";
          idx = rgbToIdx(+sR.input.value, +sG.input.value, v);
          paintByIndex(idx);
        }

        paintByIndex(idx);
        const timer = setInterval(() => {
          if (!paused && !hidden) {
            idx = (idx + 1) % TOTAL;
            paintByIndex(idx);
          }
        }, intervalMs);
        btnPause.onclick = () => {
          paused = !paused;
          btnPause.textContent = paused ? "Resume" : "Pause";
          if (!paused) paintByIndex(idx);
        };
        btnClose.onclick = () => {
          hidden = true;
          container.style.display = "none";
          paused = true;
          btnPause.textContent = "Resume";
          addRestoreButton("rgbPanel", "RGB", () => {
            hidden = false;
            container.style.display = "";
          });
        };
        (function raf() {
          controls.update();
          renderer.render(scene, camera);
          requestAnimationFrame(raf);
        })();
      }

      // ---------- HSV ----------
      function createHSVWidget(
        container,
        {
          H_STEPS = 360,
          S_STEPS = 256,
          V_STEPS = 256,
          startIndex,
          intervalMs = SECOND,
          vizHue = 72,
          vizSat = 16,
          vizVal = 12,
        } = {}
      ) {
        const TOTAL = H_STEPS * S_STEPS * V_STEPS;
        if (startIndex == null) startIndex = Math.floor(Math.random() * TOTAL);

        const { view, canvas, sliders, status, btnPause, btnClose } = makePanelScaffold(container);
        const { renderer, scene, camera, controls } = makeRendererAndScene(canvas, container);

        const cylWire = new THREE.LineSegments(
          new THREE.EdgesGeometry(new THREE.CylinderGeometry(1, 1, 1, 48, 6, true)),
          new THREE.LineBasicMaterial({ color: 0x888888 })
        );
        cylWire.position.y = 0.5;
        scene.add(cylWire);

        function hsvToRgb(h, s, v) {
          const c = v * s,
            hp = (h % 360) / 60,
            x = c * (1 - Math.abs((hp % 2) - 1));
          let r = 0,
            g = 0,
            b = 0;
          if (hp < 1) {
            r = c;
            g = x;
          } else if (hp < 2) {
            r = x;
            g = c;
          } else if (hp < 3) {
            g = c;
            b = x;
          } else if (hp < 4) {
            g = x;
            b = c;
          } else if (hp < 5) {
            r = x;
            b = c;
          } else {
            r = c;
            b = x;
          }
          const m = v - c;
          return [Math.round((r + m) * 255), Math.round((g + m) * 255), Math.round((b + m) * 255)];
        }

        const count = vizHue * vizSat * vizVal;
        const pos = new Float32Array(count * 3),
          col = new Float32Array(count * 3);
        for (let hi = 0, k = 0; hi < vizHue; hi++) {
          const h = hi * (360 / vizHue),
            ang = (h * Math.PI) / 180;
          for (let si = 0; si < vizSat; si++) {
            const s = si / (vizSat - 1);
            for (let vi = 0; vi < vizVal; vi++) {
              const v = vi / (vizVal - 1);
              pos.set([s * Math.cos(ang), v, s * Math.sin(ang)], k);
              const [r, g, b] = hsvToRgb(h, s, v);
              col.set([r / 255, g / 255, b / 255], k);
              k += 3;
            }
          }
        }
        const geo = new THREE.BufferGeometry();
        geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
        geo.setAttribute("color", new THREE.BufferAttribute(col, 3));
        scene.add(
          new THREE.Points(
            geo,
            new THREE.PointsMaterial({ size: 0.075, vertexColors: true, transparent: true, opacity: 0.9 })
          )
        );

        const marker = new THREE.Mesh(
          new THREE.SphereGeometry(0.045, 32, 32),
          new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x222222 })
        );
        scene.add(marker);

        const sH = makeSliderRow(sliders, "H", { min: 0, max: H_STEPS - 1, color: "hsl(0 100% 50%)" }, onH);
        const sS = makeSliderRow(sliders, "S", { min: 0, max: S_STEPS - 1, color: "hsl(0 100% 50%)" }, onS);
        const sV = makeSliderRow(sliders, "V", { min: 0, max: V_STEPS - 1, color: "#aaa" }, onV);

        const updateHSVSliderAccents = (hi) => {
          const h = hi * (360 / H_STEPS);
          sH.setAccent(`hsl(${h} 100% 50%)`);
          sS.setAccent(`hsl(${h} 100% 50%)`);
        };

        let idx = startIndex % TOTAL,
          paused = false,
          hidden = false;
        const idxToHSV = (i) => [i % H_STEPS, Math.floor(i / H_STEPS) % S_STEPS, Math.floor(i / (H_STEPS * S_STEPS))];
        const hsvToIdx = (h, s, v) => h + H_STEPS * (s + S_STEPS * v);

        function paintByIndex(i) {
          const [hi, si, vi] = idxToHSV(i);
          sH.input.value = sH.out.textContent = hi;
          sS.input.value = sS.out.textContent = si;
          sV.input.value = sV.out.textContent = vi;
          updateHSVSliderAccents(hi);
          const h = hi * (360 / H_STEPS),
            s = si / (S_STEPS - 1),
            v = vi / (V_STEPS - 1);
          const [r, g, b] = hsvToRgb(h, s, v);
          view.style.background = `rgb(${r}, ${g}, ${b})`;
          setBarContrast(r, g, b, status);
          const ang = (h * Math.PI) / 180;
          marker.position.set(s * Math.cos(ang), v, s * Math.sin(ang));
          status.textContent = `HSV h=${hi}/${H_STEPS} (${h.toFixed(1)}°) s=${si}/${S_STEPS} (${(s * 100).toFixed(
            1
          )}%) v=${vi}/${V_STEPS} (${(v * 100).toFixed(1)}%) • ${fmt(i + 1)} of ${fmt(TOTAL)}`;
        }
        function onH(v) {
          paused = true;
          btnPause.textContent = "Resume";
          idx = hsvToIdx(v, +sS.input.value, +sV.input.value);
          paintByIndex(idx);
        }
        function onS(v) {
          paused = true;
          btnPause.textContent = "Resume";
          idx = hsvToIdx(+sH.input.value, v, +sV.input.value);
          paintByIndex(idx);
        }
        function onV(v) {
          paused = true;
          btnPause.textContent = "Resume";
          idx = hsvToIdx(+sH.input.value, +sS.input.value, v);
          paintByIndex(idx);
        }

        paintByIndex(idx);
        const timer = setInterval(() => {
          if (!paused && !hidden) {
            idx = (idx + 1) % TOTAL;
            paintByIndex(idx);
          }
        }, intervalMs);
        btnPause.onclick = () => {
          paused = !paused;
          btnPause.textContent = paused ? "Resume" : "Pause";
          if (!paused) paintByIndex(idx);
        };
        btnClose.onclick = () => {
          hidden = true;
          container.style.display = "none";
          paused = true;
          btnPause.textContent = "Resume";
          addRestoreButton("hsvPanel", "HSV", () => {
            hidden = false;
            container.style.display = "";
          });
        };
        (function raf() {
          controls.update();
          renderer.render(scene, camera);
          requestAnimationFrame(raf);
        })();
      }

      // ---------- HSL ----------
      function createHSLWidget(
        container,
        {
          H_STEPS = 360,
          S_STEPS = 256,
          L_STEPS = 256,
          startIndex,
          intervalMs = SECOND,
          vizHue = 72,
          vizSat = 16,
          vizLig = 12,
        } = {}
      ) {
        const TOTAL = H_STEPS * S_STEPS * L_STEPS;
        if (startIndex == null) startIndex = Math.floor(Math.random() * TOTAL);

        const { view, canvas, sliders, status, btnPause, btnClose } = makePanelScaffold(container);
        const { renderer, scene, camera, controls } = makeRendererAndScene(canvas, container);

        const ring = new THREE.Mesh(
          new THREE.TorusGeometry(1, 0.003, 8, 96),
          new THREE.MeshBasicMaterial({ color: 0x777777, wireframe: true })
        );
        ring.rotation.x = Math.PI / 2;
        ring.position.y = 0.5;
        const coneTop = new THREE.Mesh(
          new THREE.ConeGeometry(1, 1, 48, 1, true),
          new THREE.MeshBasicMaterial({ color: 0x666666, wireframe: true })
        );
        coneTop.position.y = 1;
        coneTop.rotation.x = Math.PI;
        const coneBot = new THREE.Mesh(
          new THREE.ConeGeometry(1, 1, 48, 1, true),
          new THREE.MeshBasicMaterial({ color: 0x666666, wireframe: true })
        );
        scene.add(ring, coneTop, coneBot);

        function hslToRgb(h, s, l) {
          const C = (1 - Math.abs(2 * l - 1)) * s,
            hp = (h % 360) / 60,
            X = C * (1 - Math.abs((hp % 2) - 1));
          let r1 = 0,
            g1 = 0,
            b1 = 0;
          if (hp < 1) {
            r1 = C;
            g1 = X;
          } else if (hp < 2) {
            r1 = X;
            g1 = C;
          } else if (hp < 3) {
            g1 = C;
            b1 = X;
          } else if (hp < 4) {
            g1 = X;
            b1 = C;
          } else if (hp < 5) {
            r1 = X;
            b1 = C;
          } else {
            r1 = C;
            b1 = X;
          }
          const m = l - C / 2;
          return [Math.round((r1 + m) * 255), Math.round((g1 + m) * 255), Math.round((b1 + m) * 255)];
        }

        const count = vizHue * vizSat * vizLig;
        const pos = new Float32Array(count * 3),
          col = new Float32Array(count * 3);
        for (let hi = 0, k = 0; hi < vizHue; hi++) {
          const h = hi * (360 / vizHue),
            ang = (h * Math.PI) / 180;
          for (let si = 0; si < vizSat; si++) {
            const s = si / (vizSat - 1);
            for (let li = 0; li < vizLig; li++) {
              const l = li / (vizLig - 1);
              const radius = (1 - Math.abs(2 * l - 1)) * s;
              pos.set([radius * Math.cos(ang), l, radius * Math.sin(ang)], k);
              const [r, g, b] = hslToRgb(h, s, l);
              col.set([r / 255, g / 255, b / 255], k);
              k += 3;
            }
          }
        }
        const geo = new THREE.BufferGeometry();
        geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
        geo.setAttribute("color", new THREE.BufferAttribute(col, 3));
        scene.add(
          new THREE.Points(
            geo,
            new THREE.PointsMaterial({ size: 0.075, vertexColors: true, transparent: true, opacity: 0.9 })
          )
        );

        const marker = new THREE.Mesh(
          new THREE.SphereGeometry(0.045, 32, 32),
          new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x222222 })
        );
        scene.add(marker);

        const sH = makeSliderRow(sliders, "H", { min: 0, max: H_STEPS - 1, color: "hsl(0 100% 50%)" }, onH);
        const sS = makeSliderRow(sliders, "S", { min: 0, max: S_STEPS - 1, color: "hsl(0 100% 50%)" }, onS);
        const sL = makeSliderRow(sliders, "L", { min: 0, max: L_STEPS - 1, color: "#aaa" }, onL);

        const updateHSLSliderAccents = (hi) => {
          const h = hi * (360 / H_STEPS);
          sH.setAccent(`hsl(${h} 100% 50%)`);
          sS.setAccent(`hsl(${h} 100% 50%)`);
        };

        let idx = startIndex % TOTAL,
          paused = false,
          hidden = false;
        const idxToHSL = (i) => [i % H_STEPS, Math.floor(i / H_STEPS) % S_STEPS, Math.floor(i / (H_STEPS * S_STEPS))];
        const hslToIdx = (h, s, l) => h + H_STEPS * (s + S_STEPS * l);

        function paintByIndex(i) {
          const [hi, si, li] = idxToHSL(i);
          sH.input.value = sH.out.textContent = hi;
          sS.input.value = sS.out.textContent = si;
          sL.input.value = sL.out.textContent = li;
          updateHSLSliderAccents(hi);
          const h = hi * (360 / H_STEPS),
            s = si / (S_STEPS - 1),
            l = li / (L_STEPS - 1);
          const [r, g, b] = hslToRgb(h, s, l);
          view.style.background = `rgb(${r}, ${g}, ${b})`;
          setBarContrast(r, g, b, status);
          const radius = (1 - Math.abs(2 * l - 1)) * s;
          const ang = (h * Math.PI) / 180;
          marker.position.set(radius * Math.cos(ang), l, radius * Math.sin(ang));
          status.textContent = `HSL h=${hi}/${H_STEPS} (${h.toFixed(1)}°) s=${si}/${S_STEPS} (${(s * 100).toFixed(
            1
          )}%) l=${li}/${L_STEPS} (${(l * 100).toFixed(1)}%) • ${fmt(i + 1)} of ${fmt(TOTAL)}`;
        }
        function onH(v) {
          paused = true;
          btnPause.textContent = "Resume";
          idx = hslToIdx(v, +sS.input.value, +sL.input.value);
          paintByIndex(idx);
        }
        function onS(v) {
          paused = true;
          btnPause.textContent = "Resume";
          idx = hslToIdx(+sH.input.value, v, +sL.input.value);
          paintByIndex(idx);
        }
        function onL(v) {
          paused = true;
          btnPause.textContent = "Resume";
          idx = hslToIdx(+sH.input.value, +sS.input.value, v);
          paintByIndex(idx);
        }

        paintByIndex(idx);
        const timer = setInterval(() => {
          if (!paused && !hidden) {
            idx = (idx + 1) % TOTAL;
            paintByIndex(idx);
          }
        }, intervalMs);
        btnPause.onclick = () => {
          paused = !paused;
          btnPause.textContent = paused ? "Resume" : "Pause";
          if (!paused) paintByIndex(idx);
        };
        btnClose.onclick = () => {
          hidden = true;
          container.style.display = "none";
          paused = true;
          btnPause.textContent = "Resume";
          addRestoreButton("hslPanel", "HSL", () => {
            hidden = false;
            container.style.display = "";
          });
        };
        (function raf() {
          controls.update();
          renderer.render(scene, camera);
          requestAnimationFrame(raf);
        })();
      }

      // ---------- CMYK ----------
      function createCMYKWidget(container, { bits = 8, startIndex, intervalMs = SECOND, gridSteps = 12 } = {}) {
        const STEPS = 1 << bits;
        const TOTAL = STEPS ** 4;
        if (startIndex == null) startIndex = Math.floor(Math.random() * TOTAL);

        const { view, canvas, sliders, status, btnPause, btnClose } = makePanelScaffold(container);
        const { renderer, scene, camera, controls } = makeRendererAndScene(canvas, container);

        // UNIQUE VISUALIZATION: Dodecahedron
        const dodecahedron = new THREE.LineSegments(
          new THREE.EdgesGeometry(new THREE.DodecahedronGeometry(0.7)),
          new THREE.LineBasicMaterial({ color: 0x888888 })
        );
        dodecahedron.position.set(0.5, 0.5, 0.5);
        scene.add(dodecahedron);

        const cmykToRgb = (c, m, y, k) => [
          Math.round(255 * (1 - c) * (1 - k)),
          Math.round(255 * (1 - m) * (1 - k)),
          Math.round(255 * (1 - y) * (1 - k)),
        ];

        const count = gridSteps ** 3;
        const pos = new Float32Array(count * 3),
          col = new Float32Array(count * 3);
        for (let ci = 0, p = 0; ci < gridSteps; ci++) {
          for (let mi = 0; mi < gridSteps; mi++) {
            for (let yi = 0; yi < gridSteps; yi++) {
              pos.set([ci / (gridSteps - 1), mi / (gridSteps - 1), yi / (gridSteps - 1)], p);
              p += 3;
            }
          }
        }
        const geo = new THREE.BufferGeometry();
        geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
        const colAttr = new THREE.BufferAttribute(col, 3);
        geo.setAttribute("color", colAttr);
        scene.add(
          new THREE.Points(
            geo,
            new THREE.PointsMaterial({ size: 0.075, vertexColors: true, transparent: true, opacity: 0.95 })
          )
        );

        const marker = new THREE.Mesh(
          new THREE.SphereGeometry(0.045, 32, 32),
          new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x222222 })
        );
        scene.add(marker);

        const sC = makeSliderRow(sliders, "C", { max: STEPS - 1, color: "#00c4ff" }, onC);
        const sM = makeSliderRow(sliders, "M", { max: STEPS - 1, color: "#ff3af2" }, onM);
        const sY = makeSliderRow(sliders, "Y", { max: STEPS - 1, color: "#ffd400" }, onY);
        const sK = makeSliderRow(sliders, "K", { max: STEPS - 1, color: "#111" }, onK);

        let idx = startIndex % TOTAL,
          paused = false,
          hidden = false;
        const idxToCMYK = (i) => [
          Math.floor(i / STEPS ** 3) % STEPS,
          Math.floor(i / STEPS ** 2) % STEPS,
          Math.floor(i / STEPS) % STEPS,
          i % STEPS,
        ];
        const cmykToIdx = (c, m, y, k) => ((c * STEPS + m) * STEPS + y) * STEPS + k;

        function paintByIndex(i) {
          const [ci, mi, yi, ki] = idxToCMYK(i);
          sC.input.value = sC.out.textContent = ci;
          sM.input.value = sM.out.textContent = mi;
          sY.input.value = sY.out.textContent = yi;
          sK.input.value = sK.out.textContent = ki;
          const c = ci / (STEPS - 1),
            m = mi / (STEPS - 1),
            y = yi / (STEPS - 1),
            k = ki / (STEPS - 1);
          const [r, g, b] = cmykToRgb(c, m, y, k);
          view.style.background = `rgb(${r}, ${g}, ${b})`;
          setBarContrast(r, g, b, status);
          marker.position.set(c, m, y);
          for (let j = 0, p = 0; j < gridSteps; j++) {
            for (let l = 0; l < gridSteps; l++) {
              for (let n = 0; n < gridSteps; n++) {
                const [rr, gg, bb] = cmykToRgb(j / (gridSteps - 1), l / (gridSteps - 1), n / (gridSteps - 1), k);
                colAttr.array.set([rr / 255, gg / 255, bb / 255], p);
                p += 3;
              }
            }
          }
          colAttr.needsUpdate = true;
          status.textContent = `CMYK ${ci},${mi},${yi},${ki} • ${fmt(i + 1)} of ${fmt(TOTAL)}`;
        }
        function onC(v) {
          paused = true;
          btnPause.textContent = "Resume";
          idx = cmykToIdx(v, +sM.input.value, +sY.input.value, +sK.input.value);
          paintByIndex(idx);
        }
        function onM(v) {
          paused = true;
          btnPause.textContent = "Resume";
          idx = cmykToIdx(+sC.input.value, v, +sY.input.value, +sK.input.value);
          paintByIndex(idx);
        }
        function onY(v) {
          paused = true;
          btnPause.textContent = "Resume";
          idx = cmykToIdx(+sC.input.value, +sM.input.value, v, +sK.input.value);
          paintByIndex(idx);
        }
        function onK(v) {
          paused = true;
          btnPause.textContent = "Resume";
          idx = cmykToIdx(+sC.input.value, +sM.input.value, +sY.input.value, v);
          paintByIndex(idx);
        }

        paintByIndex(idx);
        const timer = setInterval(() => {
          if (!paused && !hidden) {
            idx = (idx + 1) % TOTAL;
            paintByIndex(idx);
          }
        }, intervalMs);
        btnPause.onclick = () => {
          paused = !paused;
          btnPause.textContent = paused ? "Resume" : "Pause";
          if (!paused) paintByIndex(idx);
        };
        btnClose.onclick = () => {
          hidden = true;
          container.style.display = "none";
          paused = true;
          btnPause.textContent = "Resume";
          addRestoreButton("cmykPanel", "CMYK", () => {
            hidden = false;
            container.style.display = "";
          });
        };
        (function raf() {
          controls.update();
          renderer.render(scene, camera);
          requestAnimationFrame(raf);
        })();
      }

      // ---------- YUV ----------
      function createYUVWidget(
        container,
        { Y_STEPS = 256, U_STEPS = 256, V_STEPS = 256, startIndex, intervalMs = SECOND, gridSteps = 12 } = {}
      ) {
        const TOTAL = Y_STEPS * U_STEPS * V_STEPS;
        if (startIndex == null) startIndex = Math.floor(Math.random() * TOTAL);

        const { view, canvas, sliders, status, btnPause, btnClose } = makePanelScaffold(container);
        const { renderer, scene, camera, controls } = makeRendererAndScene(canvas, container);

        // UNIQUE VISUALIZATION: Octahedron
        const octahedron = new THREE.LineSegments(
          new THREE.EdgesGeometry(new THREE.OctahedronGeometry(0.7)),
          new THREE.LineBasicMaterial({ color: 0x888888 })
        );
        octahedron.position.set(0.5, 0.5, 0.5);
        scene.add(octahedron);

        function yuvToRgb(y, u, v) {
          const r = y + 1.13983 * v;
          const g = y - 0.39465 * u - 0.5806 * v;
          const b = y + 2.03211 * u;
          return [Math.round(255 * clamp01(r)), Math.round(255 * clamp01(g)), Math.round(255 * clamp01(b))];
        }

        const count = gridSteps ** 3;
        const pos = new Float32Array(count * 3),
          col = new Float32Array(count * 3);
        for (let yi = 0, k = 0; yi < gridSteps; yi++) {
          const y = yi / (gridSteps - 1);
          for (let ui = 0; ui < gridSteps; ui++) {
            const u = ui / (gridSteps - 1) - 0.5;
            for (let vi = 0; vi < gridSteps; vi++) {
              const v = vi / (gridSteps - 1) - 0.5;
              pos.set([u + 0.5, y, v + 0.5], k);
              const [r, g, b] = yuvToRgb(y, u, v);
              col.set([r / 255, g / 255, b / 255], k);
              k += 3;
            }
          }
        }
        const geo = new THREE.BufferGeometry();
        geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
        geo.setAttribute("color", new THREE.BufferAttribute(col, 3));
        scene.add(
          new THREE.Points(
            geo,
            new THREE.PointsMaterial({ size: 0.075, vertexColors: true, transparent: true, opacity: 0.9 })
          )
        );

        const marker = new THREE.Mesh(
          new THREE.SphereGeometry(0.045, 32, 32),
          new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x222222 })
        );
        scene.add(marker);

        const sY = makeSliderRow(sliders, "Y", { max: Y_STEPS - 1, color: "#aaa" }, onY);
        const sU = makeSliderRow(sliders, "U", { max: U_STEPS - 1, value: 128, color: "#2d7dff" }, onU);
        const sV = makeSliderRow(sliders, "V", { max: V_STEPS - 1, value: 128, color: "#ff3a7a" }, onV);

        let idx = startIndex % TOTAL,
          paused = false,
          hidden = false;
        const idxToYUV = (i) => [i % Y_STEPS, Math.floor(i / Y_STEPS) % U_STEPS, Math.floor(i / (Y_STEPS * U_STEPS))];
        const yuvToIdx = (y, u, v) => y + Y_STEPS * (u + U_STEPS * v);

        function paintByIndex(i) {
          const [y_i, u_i, v_i] = idxToYUV(i);
          sY.input.value = sY.out.textContent = y_i;
          sU.input.value = u_i;
          sU.out.textContent = u_i - 128;
          sV.input.value = v_i;
          sV.out.textContent = v_i - 128;
          const y = y_i / (Y_STEPS - 1),
            u = u_i / (U_STEPS - 1) - 0.5,
            v = v_i / (V_STEPS - 1) - 0.5;
          const [r, g, b] = yuvToRgb(y, u, v);
          view.style.background = `rgb(${r}, ${g}, ${b})`;
          setBarContrast(r, g, b, status);
          marker.position.set(u + 0.5, y, v + 0.5);
          status.textContent = `YUV Y=${y_i} U=${u_i - 128} V=${v_i - 128} • ${fmt(i + 1)} of ${fmt(TOTAL)}`;
        }
        function onY(v) {
          paused = true;
          btnPause.textContent = "Resume";
          idx = yuvToIdx(v, +sU.input.value, +sV.input.value);
          paintByIndex(idx);
        }
        function onU(v) {
          paused = true;
          btnPause.textContent = "Resume";
          idx = yuvToIdx(+sY.input.value, v, +sV.input.value);
          paintByIndex(idx);
        }
        function onV(v) {
          paused = true;
          btnPause.textContent = "Resume";
          idx = yuvToIdx(+sY.input.value, +sU.input.value, v);
          paintByIndex(idx);
        }

        paintByIndex(idx);
        const timer = setInterval(() => {
          if (!paused && !hidden) {
            idx = (idx + 1) % TOTAL;
            paintByIndex(idx);
          }
        }, intervalMs);
        btnPause.onclick = () => {
          paused = !paused;
          btnPause.textContent = paused ? "Resume" : "Pause";
          if (!paused) paintByIndex(idx);
        };
        btnClose.onclick = () => {
          hidden = true;
          container.style.display = "none";
          paused = true;
          btnPause.textContent = "Resume";
          addRestoreButton("yuvPanel", "YUV", () => {
            hidden = false;
            container.style.display = "";
          });
        };
        (function raf() {
          controls.update();
          renderer.render(scene, camera);
          requestAnimationFrame(raf);
        })();
      }

      // ---- bootstrap ----
      createRGBWidget(document.getElementById("rgbPanel"));
      createHSVWidget(document.getElementById("hsvPanel"));
      createHSLWidget(document.getElementById("hslPanel"));
      createCMYKWidget(document.getElementById("cmykPanel"));
      createYUVWidget(document.getElementById("yuvPanel"));
    </script>
  </body>
</html>
